'use strict';
const Serializer = require('parse5/lib/serializer');
const url = require('url');
module.exports = class CustomSerializer extends Serializer {

    pushBuffer() {
        console.log("start pushBuffer");
        if (this.html !== '') {
            console.log("this.html=" + this.html);
            this.serializedList.push(new Buffer(this.html));
            this.html = '';
        }
        console.log("end pushBuffer");
    }

    constructor(node, options, request, getServiceUrl) {
        console.log("   start constructor");
        console.log("node=" + JSON.stringify(node.name));
        super(node, options);
        this.nodeCount = 0;
        this.childNodesCount = 0;
        this.slotMap = options.slotMap;
        this.handleTags = options.handleTags;
        this.pipeTags = options.pipeTags;
        this.isPipeInserted = false;
        this.lastChildInserted = false;
        this.serializedList = [];
        this._serializeNode = this._serializeNode.bind(this);
        this.defaultSlotsInserted = false;
        this.request = request;
        this.getServiceUrl = getServiceUrl;
    }

    serialize() {
        this._serializeChildNodes(this.startNode);
        this.pushBuffer();
        console.log("serialize serializedList=" + JSON.stringify(this.serializedList));
        return this.serializedList;
    }

    _isPipeNode(node) {
        return this.pipeTags.indexOf(node.name) !== -1;
    }

    _isSlotNode(node) {
        if (node.name === 'slot') {
            return true;
        }
        const attribs = node.attribs;
        return node.name === 'script' &&
            attribs && attribs.type === 'slot';
    }

    _isSpecialNode(node) {
        if (this.handleTags.indexOf(node.name) !== -1) {
            return true;
        }
        const attribs = node.attribs;
        if (attribs && attribs.type) {
            return node.name === 'script' && this.handleTags.indexOf(attribs.type) !== -1;
        }
        return false;
    }

    _isLastChildOfBody(node) {
        const parentNode = node.parent;
        if (parentNode.name === 'body') {
            if (Object.is(node, parentNode.lastChild)) {
                return true;
            }
        }
        return false;
    }

    _serializeSpecial(node) {
        console.log("start    _serializeSpecial\n");
        this.pushBuffer();
        let fragmentObj;
        //根据url获取frame
        let src = "";
        if (this.request && this.getServiceUrl) {
            src = url.parse(this.request.url, true).pathname;
            node.attribs.src = this.getServiceUrl(src);
        }
        if (this.handleTags.indexOf(node.name) !== -1) {
            fragmentObj = Object.assign({}, {name: node.name, attributes: node.attribs});
        } else {
            fragmentObj = Object.assign({}, {name: node.attribs.type, attributes: node.attribs});
        }
        this.serializedList.push(fragmentObj);
        this._serializeChildNodes(node);
        this.pushBuffer();
        this.serializedList.push({closingTag: node.name});
        console.log("end    _serializeSpecial\n");
    }

    _serializeSlot(node) {
        const slotName = node.attribs.name;
        if (slotName) {
            const childNodes = this.treeAdapter.getChildNodes(node);
            let slots = childNodes;
            if (this.slotMap.has(slotName)) {
                slots = this.slotMap.get(slotName);
            }
            console.log("start   slots:::::::::::::::");
            slots && slots.forEach(this._serializeNode);
            console.log("end     slots:::::::::::::::\n");
        } else {
            if (this.defaultSlotsInserted) {
                console.warn('Encountered duplicate Unnamed slots in the template - Skipping the node');
                return;
            }
            const defaultSlots = this.slotMap.get('default');
            this.defaultSlotsInserted = true;
            defaultSlots && defaultSlots.forEach(this._serializeNode);
        }
    }

    _serializePipe(node) {
        this.pushBuffer();
        this.serializedList.push({placeholder: 'pipe'});
        this.isPipeInserted = true;
        this._serializeNode(node);
    }

    _serializeRest() {
        this.lastChildInserted = true;
        if (!this.defaultSlotsInserted) {
            const defaultSlots = this.slotMap.get('default');
            defaultSlots && defaultSlots.forEach(this._serializeNode);
        }
        this.pushBuffer();
        this.serializedList.push({placeholder: 'async'});
        console.log("_serializeRest serializedList=" + JSON.stringify(this.serializedList));
    }

    _serializeChildNodes(parentNode) {
        console.log("start   _serializeChildNodes" + this.childNodesCount++ + "\n");
        const childNodes = this.treeAdapter.getChildNodes(parentNode);
        if (childNodes) {
            childNodes.forEach(function (node) {
                console.log("@@@@@@@@@@@@@@---------");
                console.log("node.name=" + JSON.stringify(node.name) + ",node.type=" + JSON.stringify(node.type));
                console.log("@@@@@@@@@@@@@@+++++++++\n");
            });
            childNodes.forEach(this._serializeNode);
        }
        console.log("end   _serializeChildNodes" + this.childNodesCount++ + "\n");
    }

    _serializeNode(currentNode) {
        console.log("########################");
        console.log("before serializedList=" + JSON.stringify(this.serializedList));
        console.log("currentNode.name=" + JSON.stringify(currentNode.name) + ",currentNode.type=" + JSON.stringify(currentNode.type));
        console.log("currentNode.data=" + JSON.stringify(currentNode.data));
        console.log("currentNode.attribs=" + JSON.stringify(currentNode.attribs));
        console.log("count:" + this.nodeCount++ + "\n");

        if (!this.isPipeInserted && this._isPipeNode(currentNode)) {
            console.log("_isPipeNode");
            this._serializePipe(currentNode);
        } else if (this._isSpecialNode(currentNode)) {
            console.log("_isSpecialNode");
            this._serializeSpecial(currentNode);
        } else if (this._isSlotNode(currentNode)) {
            console.log("_isSlotNode");
            this._serializeSlot(currentNode);
        } else if (this.treeAdapter.isElementNode(currentNode)) {
            console.log("isElementNode");
            this._serializeElement(currentNode);
        } else if (this.treeAdapter.isTextNode(currentNode)) {
            console.log("isTextNode");
            this._serializeTextNode(currentNode);
        } else if (this.treeAdapter.isCommentNode(currentNode)) {
            console.log("isCommentNode");
            this._serializeCommentNode(currentNode);
        } else if (this.treeAdapter.isDocumentTypeNode(currentNode)) {
            console.log("isDocumentTypeNode");
            this._serializeDocumentTypeNode(currentNode);
        }
        // Push default slots and async placeholder before body
        if (!this.lastChildInserted && this._isLastChildOfBody(currentNode)) {
            console.log("_isLastChildOfBody");
            this._serializeRest();
        }
    }

};
